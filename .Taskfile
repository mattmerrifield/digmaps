#!/bin/bash
set -euo pipefail
IFS=$'\n\t'

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )";
function dc() {
    # Alias to docker compose that always chooses the right
    # compose file
    local FILENAME=$DIR/docker-compose.yml;
    docker-compose -f $FILENAME $@

}

function dc_do() {
    # Runs the given command in docker-compose in an existing
    # container if there is one, or spins up a new one if there
    # isn't.
    #
    # Among other things, this lets us keep the DB up and
    # running all the time, but bring up the API, front-end
    # compiler, or the web container only temporarily to run
    # a specific command
    local IS_RUNNING=$(docker-compose ps -q $1)
    if [[ "$IS_RUNNING" != "" ]]; then
        local do=exec
    else
        local do=run
    fi
    dc $do $@
}

function bash() {
    # Grab a bash shell on the named container (api by default)
    local container_name=${1:-api};
    # Pass the rest of the args to bash directly
    if [ "$#" != "0" ]; then
        shift;
    fi
    dc_do $container_name bash $@;
}

function pip_freeze() {
    # Update pip requirements
    local requirements_file=$(DIR/api/frozen_requirements.txt)
    echo "Freezing pip requirements to $requirements_file";
    dc_do api pip freeze > $requirements_file;
    echo "Done"
}

function manage () {
    # Run the django management command in the API container
    dc_do api python manage.py $@;
}

function dbshell() {
    # Get a database shell in the existing docker container
    dc_do db psql --user postgres;
}

# This "$@" construct means we will run this file as if it were a
# standalone script. The first argument will be the command to run
# (which should be a function from within the file) and the rest
# of the args are passed to that command.
"$@"